spring 学习记录
=======

# spring 实战

## 第 1 章 Spring 之旅

#### Spring 的目的是什么？

简化 Java 开发

#### 怎么简化 java 开发？

- 基于 pojo 轻量级和最小侵入编程
- 依赖注入(DI)/控制反转(IOC) 实现解耦合
- 面向切面编程(AOP) 声明式编程和减少样样板代码

#### 不用 DI/IOC 有什么问题？

每个对象都要管理它依赖的对象，造成耦合性太高和难以测试和复用

> 比如每个对象还要 new 出来

#### DI 怎么实现的呢？

通过系统中负责协调的`第三方组件`在创建对象的时候设定对象的依赖关系

#### 有哪些 DI 注入的方式？

方式|备注
----|----
构造器|注入的是接口，不是实现类(更加的通用和灵活)bang　
组合|


#### 什么是装配？

创建应用组件之间协作的行为

> 就好像汽车中各个配件组合到一起做成发动机

#### 有哪些装配的方式？

- XML
- 基于 java 配置(比如注解,如 @Bean)

> 我们可以把这个过程成想象成变形金刚变形合体，spring 把各种 bean 装配到一起形成一个“巨型大金刚”，爆发出的能量超乎单体作战的想象！👽

#### spring 是通过什么来完成装配的呢？

谜底揭晓！ **ApplicationContext(应用上下文)** 装载bean的定义并把它们组装起来

#### AOP 有什么用？

把应用中各处分散的功能分离出来，形成可复用的组件

> 比如我们常见的日志模块、事务管理、安全等等，都是一些通用的模块或功能
> 
> 你想想啊，如果除了核心的代码逻辑，每一个地方你都要维护类似于日志、事务、安全的代码，万一需求变更，头都大了🤪

#### 为什么要 AOP?

- 实现`横向关注点`(经常使用到的系统服务，如日志、安全等)功能的代码会重复出现在多个组件中，维护繁琐

> 丑陋的 ctrl c + ctrl v 真的有必要么

- 各个组件会因为与自身业务无关的代码变得混乱

> 想象一下一个支付的组件，日志、安全、事务等混杂其中，你会想，这到底要干什么(实际它的核心代码只是为了实现支付)

- AOP 就可以将横向关注点**服务模块化**【分离的思想】

> 这个你可以想象一下，各个横向关注点的功能层像外壳一样包裹着核心业务层📦，就好像钢铁侠穿上了高科技的钢铁套装，既变得很厉害，又没有给自己增加太大负担。

#### AOP 定义切点时用什么语法？

pointcut 配置expression 属性来选择所应用的通知,表达式的语法采用的是`AspectJ`的切点表达式语言

> AspectJ 用来做 AOP 很强大，Spring AOP 也有参考 AspectJ 来做，一般开发也足够用

#### 你能举几个样板代码的例子吗？

例子：比如JDBC，为了进行一个简单的数据库操作，需要写一大堆样本代码，处理无关的数据库连接、sql 语句、返回结果解析、异常处理等等

#### 怎么解决样板代码？

使用模板封装

> 比如 JdbcTemplate 很好地封装了 JDBC 的处理，有兴趣查看源码实现 

#### 你的 bean 在应用中是如何管理的？

Spring 容器负责创建、装配、配置、管理 bean 的整个生命周期，从出生--->死亡。

> 可见 `容器` 是 spring 的核心。

#### spring 有哪些类型的容器

- 最简单的容器:BeanFactory
- 常用的容器:ApplicationContext（基于BeanFactory构建）

> BeanFactory 对大多数应用来说往往太低级了，因此，ApplicationContext 更受欢迎。这就好比现在有了电锯去砍树，偏偏使用最原始的手工铁据，是不是有点费力不讨好。

#### spring 有哪些常见的应用上下文？

种类|描述
----|----
AnnotationConfigApplicationContext|从一个或多个基于Java的配置类中加载Spring应用上下文。
AnnotationConfigWebApplicationContext|从一个或多个基于Java的配置类中加载Spring Web应用上下文。
ClassPathXmlApplicationContext|从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。
FileSystemXmlapplicationcontext|从文件系统下的一个或多个XML配置文件中加载上下文定义。
XmlWebApplicationContext|从Web应用下的一个或多个XML配置文件中加载上下文定义。

#### 传统的 bean 生命周期是什么样的？

一般就是使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。

> 简单粗暴，在 new 或者销毁回收 的过程能够做的事非常有限，操作也很麻烦(比如用反射)

#### Spring bean的生命周期是什么样的？[非常重要]

<div align="center"> <img src="pics/1-1.png" width="500" style="zoom:100%"/> </div><br>

在bean准备就绪之前，bean工厂执行了若干启动步骤。我们对图1.5进行详细描述：

1.Spring对bean进行实例化

2.Spring将值和bean的引用(引用其他bean)注入到bean对应的属性中

> 比如通过构造函数、类中注入的接口/类的引用

3.如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；

4.如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；

5.如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；

> 3个 aware,从名字上看的出，它实现这个接口是为了让自己被发现（“意识到”），至于具体你想让自己什么东西被容器发现并生效，就选用合适的接口

6.如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法；

7.如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；

8.如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；

> BeanPostProcessor 和 InitializingBean的3个方法之间的关系就好像汉堡包🍔中的两块面包(before/after)和夹心鸡肉🍗(afterPropertiesSet)

9.此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；

10.如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。

#### spring 有哪些核心的模块？

<div align="center"> <img src="pics/1-2.png" width="500" style="zoom:100%"/> </div><br>

#### spring 5.x 有哪些新特性？

todo

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####
####

####

####

####

####

####

####

####

####

####

####


####

####

####

####

####

####

####

####

####

####

####

# spring 企业应用开发实战


####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####

####
####

####

####

####

####

####

####

####

####

####

####


####

####

####

####

####

####

####

####

####

####

####



