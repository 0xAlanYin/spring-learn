第 3 章 默认标签的解析
====

之前我们提到过 spring 中的标签包括默认的标签和自定义标签，这一站，让我们一起来看看的默认标签的风光吧～

> 还记得上一站咱们到过哪嘛，好吧，我想你可能已经忘记了，让我们再回去看一样，没错，就是 DefaultBeanDefinitionDocumentReader 的 doRegisterBeanDefinitions 方法，其中最后一个景点是 parseBeanDefinitions(root, this.delegate);

首先我们先来看本站核心函数 parseDefaultElement，方法中逻辑一目了然，分别对 4 种不同的标签 (import、alias、bean、beans) 做了不同的处理。

``` java
DefaultBeanDefinitionDocumentReader:
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		// 对 import 标签的处理
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		// 对 alias 标签的处理
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		// 对 bean 标签的处理【最复杂最重要】
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		// 对 beans 标签的处理
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse
			doRegisterBeanDefinitions(ele);
		}
	}
```

## 3.1 bean 标签的解析及注册

我们知道 spring 最重要的管理目标是 bean， 所以这 4 种标签当中对 bean 标签的解析最重要也最复杂，本着“二八法则”和“擒贼先擒王”的原则，我们先来分析一下 bean 标签的解析，其他标签自然手到擒来，让我们进入 parseDefaultElement(ele, delegate)。

#### bean 标签的主要解析步骤是什么样的？

``` java
DefaultBeanDefinitionDocumentReader:
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error("Failed to register bean definition with name '" +
						bdHolder.getBeanName() + "'", ele, ex);
			}
			// Send registration event.
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

初次一看感觉一头雾水，逻辑不是特别清晰。大概的逻辑其实是这样的：

1.首先委托 BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement 方法进行元素解析，返回 BeanDefinitionHolder 类型的实例 bdHolder，经过这个方法后，bdHolder 实例已经包含我们配置文件中配置的各种属性了，例如 class、name、id、alias之类的属性。

> 这里传进去的就是我们前面准备好的 Element，经过这个“委托人”一处理，就有了我们想要的配置文件中的各种属性。
> 
> BeanDefinitionHolder 的名字也很想形象，将各种属性“hold”住，很有意思吧。
 
2.当返回的 bdHolder 不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次**对自定义标签进行解析**。

3.解析完成后，需要对解析后的 bdHolder 进行注册，同样，注册操作委托给了 Bean­DefinitionReaderUtils 的registerBeanDefinition 方法。

> 看到这个方法你就知道了，通过各种“委托”，各种处理其实是交给“别人”(bean)去做，自己其实主要掌握总体的步骤即可，“事必亲躬”可不是 spring 的风格。

4.最后发出响应事件，通知相关的监昕器，这个bean已经加载完成了。 配合时序图(见图 3-1 )，可能会更容易理解。

一图胜千言，让我们结合时序图来看下吧:

<div align="center"> <img src="pics/3-1.png" width="500" style="zoom:100%"/> </div><br>

### 3.1.1 解析 BeanDefinition（parseBeanDefinitionElement方法）

了解了总体的步骤，下面让我们一步步来“各个击破”。首先我们从元素解析及信息提取开始吧，也就是 `BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);`，进入 BeanDefinitionHolder 的 parseBeanDefinitionElement 方法瞧一瞧。

#### 对默认标签解析 BeanDefinition 的全过程是什么样的呢？

``` java
BeanDefinitionHolder:
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}

// 解析 bean定义的元素(<bean>标签)
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		// 解析 id 属性
		String id = ele.getAttribute(ID_ATTRIBUTE);
		// 解析 name 属性
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

		// 分割 name 属性
		List<String> aliases = new ArrayList<>();
		if (StringUtils.hasLength(nameAttr)) {
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}

		String beanName = id;
		// 如果没有 id 属性，那就拿个别名来作为它的 beanName
		if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace("No XML 'id' specified - using '" + beanName +
						"' as bean name and " + aliases + " as aliases");
			}
		}

		if (containingBean == null) {
			checkNameUniqueness(beanName, aliases, ele);
		}

		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		if (beanDefinition != null) {
			if (!StringUtils.hasText(beanName)) {
				try {
					// 如果不存在 beanName，那么根据 spring 中提供的命名规则为当前 bean 生成对应的 beanName
					if (containingBean != null) {
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					} else {
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
						String beanClassName = beanDefinition.getBeanClassName();
						if (beanClassName != null &&
								beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace("Neither XML 'id' nor 'name' specified - " +
								"using generated bean name [" + beanName + "]");
					}
				} catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
```

> todo
> 
> 1.分割 name 属性是做什么？对应 bean 标签什么属性设置？

> ```
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
> 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
> 	xmlns:p="http://www.springframework.org/schema/p"
> 	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
> 
>   <bean id="compactDisc" class="soundsystem.BlankDisc">
>     <constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
>     <constructor-arg value="The Beatles" />
>   </bean>
>         
>   <bean id="cdPlayer" class="soundsystem.properties.CDPlayer">
>     <property name="compactDisc" ref="compactDisc" />
>   </bean>
> 
> </beans>
> ```

以上就是对默认标签解析的全过程了，看完之后是不是还是很困惑？

> 小贴士：
> 
> (这里有个小建议，由于单独看代码的变量名可能不是那么直观，你可以找一个bean 的 xml文件对照一起理解，这样便于在你的脑海中逐一映射上，上面我就随意给了一个示例)。

当然，对 Spring 的解析犹如洋葱剥皮一样， 一层一层地进行，尽管现在我们只能从上面的代码看到对属性 id 以及 name 的解析，但是很庆幸，思路我们至少已经了解了。 

在展开对属性的全面解析之前，Spring 在外层又做了一个当前层的功能架构，在当前层完成的主要工作包括如下内容:

1. 提取元素中的 id 以及 name 属性。
2. 进一步解析其他所有属性并统一封装至 GenericBeanDefinition 类型的实例中。
3. 如果检测到 bean 没有指定 beanName，那么使用默认规则为此 Bean 生成 beanName。
	
> (默认规则就是用类名，首字母小写)
> 
> 毕竟每一个 bean 在 spring 中是要有身份的，既然你“舍不得”指定名字，那只好给个默认名字了，去个“外号”也行。

4.将获取到的信息封装到 BeanDefinitionHolder 的实例中 。

#### 我们进一步地查看步骤 2 中对标签其他属性的解析过程。

```
// 解析 bean定义的元素(<bean>标签)
	@Nullable
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {

		this.parseState.push(new BeanEntry(beanName));

		String className = null;
		// 解析 class 属性
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
		}
		String parent = null;
		// 解析 parent 属性
		if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
			parent = ele.getAttribute(PARENT_ATTRIBUTE);
		}

		try {
			// 创建用于承载属性的 AbstractBeanDefinition 类型的 GenericBeanDefinition
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);

			// 硬编码解析默认 bean 的各种属性
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
			// 提取 description
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

			// 解析元数据
			parseMetaElements(ele, bd);
			// 解析 lookup-method 属性
			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			// 解析 replace-method 属性
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

			// 解析构造函数参数
			parseConstructorArgElements(ele, bd);
			// 解析 property 子元素
			parsePropertyElements(ele, bd);
			// 解析 qualifier 子元素:用于消除相同 beanName 的歧义
			parseQualifierElements(ele, bd);

			bd.setResource(this.readerContext.getResource());
			bd.setSource(extractSource(ele));

			return bd;
		} catch (ClassNotFoundException ex) {
			error("Bean class [" + className + "] not found", ele, ex);
		} catch (NoClassDefFoundError err) {
			error("Class that bean class [" + className + "] depends on not found", ele, err);
		} catch (Throwable ex) {
			error("Unexpected failure during bean definition parsing", ele, ex);
		} finally {
			this.parseState.pop();
		}

		return null;
	}
```

到这次，bean 标签的所有属性，不论常用的还是不常用的我们都看到了。当然，尽管有些复杂的属性还需要进一步的解析，不过这一点也不会影响我们兴奋的心情(毕竟好不容易终于把那“难弄”的复杂的 xml 配置的属性逐一解析出来了)。 

> 其实这里解析的属性，就是我们可以在 xml 文件中定义的属性(除去这里的之外的属性，可见代码也是不支持滴)。

接下来，我们继续一些复杂标签属性的解析。

#### 3.1.1.1 创建用于属性承载的 BeanDefinition

#### 让我们总览一下 BeanDefinition
BeanDefinition 是一个接口，在 Spring 中有三种实现: RootBeanDefinition、 ChildBean­Definition 以及 GenericBeanDefinition。

这三种实现均继承了 AbstractBeanDefiniton ，其中 BeanDefinition 是配置文件<bean>元素标签在容器中的内部表示形式。 <bean>元素标签拥有 class、 scope、 lazy-init 等配置属性，BeanDefinition 则提供了相应的 beanClass、scope、lazyInit 属性， BeanDefinition和<bean>中的属性是-一对应的。

> @yx
> 
> 看到这里你应该能想象出来， xml 中的 <bean> 标签的每一个的属性都是和 BeanDefinition 一一对应的，没错，他们可以理解成“映射”上了。

其中 RootBeanDefinition是最常用的实现类，它对应一般性的 <bean> 元素标签，GenericBeanDefinition 是自 2.5 版本以后新加入的 bean 文件配置属性定义类，是一站式服务类。(各种操作应有尽有，给你“一条龙”的服务)

在配置文件中可以定义父`<bean>` 和子`<bean>` ，父` <bean>` 用 RootBeanDefinition 表示，而子 `<bean>`用 ChildBeanDefiniton 表示，而没有父`<bean>`的`<bean>`就使用 RootBeanDefinition 表示。AbstractBeanDefinition 对两者共同的类信息进行抽象。

> @yx
> 
> 无论是 jdk 源码还是 spring 源码，你总能看到很多的抽象类，对于那种存在 “is-a” 关系并且希望实现代码复用的类，抽象类是一个很不错的选择。

Spring 通过 BeanDefinition 将配置文件中的` <bean>` 配置信息转换为容器的内部表示，并将这些 BeanDefiniton 注册到 BeanDefinitonRegistry 中。Spring容器的 BeanDefinitionRegistry 就像是 Spring配置信息的内存数据库，主要是以 map 的形式保存，后续操作直接从 BeanDefinition­Registry 中读取配置信息。 

> @yx
> 
> BeanDefinitionRegistry 就像是一个 spring “内置数据库”，保存了所有的 BeanDefiniton，他就是一个“大管家”，把 BeanDefiniton 都存起来，等你要用的时候找他要。

它们之间的关系如图 3-2 所示。

<div align="center"> <img src="pics/3-2.png" width="500" style="zoom:100%"/> </div><br>

根据以上的内容可知，要解析属性首先要做的就是**创建用于承载属性的实例**，也就是创建 GenericBeanDefinition
类型的实例。 而代码 createBeanDefinition(className, parent)的作用就是实现此功能，接下来让我们看下代码吧。

``` java
BeanDefinitionParserDelegate:
protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());
	}
```

``` java
BeanDefinitionReaderUtils:
public static AbstractBeanDefinition createBeanDefinition(
			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

		GenericBeanDefinition bd = new GenericBeanDefinition();
		// parent 可能为空
		bd.setParentName(parentName);
		if (className != null) {
			if (classLoader != null) {
				// 如果 classLoader 不为空，则使用以传入的 classLoader 同一虚拟机加载类对象；否则只是记录 className
				bd.setBeanClass(ClassUtils.forName(className, classLoader));
			} else {
				bd.setBeanClassName(className);
			}
		}
		return bd;
	}
```

#### 3.1.1.2 解析各种属性
经过上一个步骤，我们已经创建好了 bean 信息的承载实例，现在我们可以进行 bean 信息的各种属性解析了。

首先，让我们进入 parseBeanDefinitionAttributes 方法，该方法是对 element 所有元素属性进行解析：

```
BeanDefinitionParserDelegate:
// Spring 完成对所有 bean 属性的解析
	public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
																@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {

		// 解析 singleton 属性
		if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
			// scope 与 singleton 两个属性只能指定其中之一，不可以同时出现， 否则 Sprinq将会报异常
			error("Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration", ele);
			// 解析 scope 属性
		} else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
			bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
		} else if (containingBean != null) {
			// Take default from containing bean in case of an inner bean definition.
			// 在嵌入 beanDifinition 情况下且没有单独指定 scope 属性则佼用父类默认的属性
			bd.setScope(containingBean.getScope());
		}

		// 解析 abstract 属性
		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
			bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
		}

		// 解析 lazy-init 属性
		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
		if (isDefaultValue(lazyInit)) {
			lazyInit = this.defaults.getLazyInit();
		}
		// 若没有设置号或设置成其他字何都会被设置为 false
		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));


		// 解析 autowire 属性
		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
		bd.setAutowireMode(getAutowireMode(autowire));

		// 解析 depends-on 属性
		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
			String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
			bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
		}

		// 解析 autowire-candidate 属性
		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
		if (isDefaultValue(autowireCandidate)) {
			String candidatePattern = this.defaults.getAutowireCandidates();
			if (candidatePattern != null) {
				String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
				bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
			}
		} else {
			bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
		}

		// 解析 primary 属性
		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
			bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
		}

		// 解析 init-method 属性
		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
			String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
			bd.setInitMethodName(initMethodName);
		} else if (this.defaults.getInitMethod() != null) {
			bd.setInitMethodName(this.defaults.getInitMethod());
			bd.setEnforceInitMethod(false);
		}

		// 解析 destroy-method 属性
		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
			String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
			bd.setDestroyMethodName(destroyMethodName);
		} else if (this.defaults.getDestroyMethod() != null) {
			bd.setDestroyMethodName(this.defaults.getDestroyMethod());
			bd.setEnforceDestroyMethod(false);
		}

		// 解析 factory-method 属性
		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
			bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
		}
		// 解析 factory-bean 属性
		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
			bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
		}

		return bd;
	}
```

通过这个方法我们可以看到 spring 完成了所有 bean 属性的解析，里面有一部分是平时比较常用的，还有一部分可能大家很少使用或不熟悉，你如果有兴趣可以去查阅相关资料了解一下。

#### 3.1.1.3 解析子元素 meta

在开始解析元数据的分析前，让我们先回顾一下元数据 meta 属性是怎么使用的吧。

> ```
> <bean id=”myTestBean” class=”bean.MyTestBean”>
> 	<meta key=”testStr" value=”aaaaaa”/>
> </bean>
> ```

这段代码并不会体现在 MyTestBean 的属性当中，而是一个额外的声明，当需要使用里面的信息的时候可以通过 BeanDefinition 的 getAttribute(key) 方法进行获取。

#### 对 meta 属性的解析是怎样的？

```
BeanDefinitionParserDelegate:
	/**
	 * Parse the meta elements underneath the given element, if any.
	 */
	public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
		// 获取当前节点的所有子元素
		NodeList nl = ele.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++) {
			Node node = nl.item(i);
			// 提取 meta
			if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {
				Element metaElement = (Element) node;
				String key = metaElement.getAttribute(KEY_ATTRIBUTE);
				String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
				// 使用 key、value 构造 BeanMetadataAttribute
				BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
				attribute.setSource(extractSource(metaElement));
				// 记录信息
				attributeAccessor.addMetadataAttribute(attribute);
			}
		}
	}
```

#### 3.1.1.4 解析子元素 lookup-method

> 子元素 lookup-method 好像在平时并不是很常用，但是在某些时候它的确是非常有用的属性，通常我们称它为获取器注入。 

用 Springin Action 中的话说: **获取器注入**是一种特殊的方法注入，它是把一个方法声明为返回某种类型的 bean，但实际要返回的 bean 是在配置文件里面配置的，此方法可用在设计有些**可插拔的功能**，解除程序依赖。 


####  lookup-method 怎么使用？
这么说有点抽象，让我们来看个具体的例子:

```
/**
 * 1. 首先我们创建一个父类。
 */

public class User {

    public void showMe() {
        System.out.println("i am user");
    }
}
```


```
/**
 * 2. 创建其子类并覆盖showMe方法。
 */

public class Teacher extends User {

    @Override
    public void showMe() {
        System.out.println("i am Teacher");
    }
}
```

```
/**
 * 2. 创建其子类并覆盖showMe方法。
 */

public class Teacher extends User {

    @Override
    public void showMe() {
        System.out.println("i am Teacher");
    }
}
```

```
/**
 * 3. 创建调用方法。
 */

public abstract class GetBeanTest {

    public void showMe() {
        this.getBean().showMe();
    }

    public abstract User getBean();
}
```

```
	/**
     * 4. 创建测试方法。
     */
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("com/alan/yx/springSource/chapter_3/lookup_method/lookupTest.xml");
        GetBeanTest getBeanTest = (GetBeanTest) context.getBean("getBeanTest");
        getBeanTest.showMe();
    }
```

到现在为止，除了配置文件外，整个测试方法就完成了，如果之前没有接触过获取器注入, 那你一定有疑问:抽象方法还没有被实现，怎么可以直接调用呢? ===》 答案在于 Spring为我们提供的获取器中，我们看看配置文件是怎么配置的。

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="getBeanTest" class="com.alan.yx.springSource.chapter_3.lookup_method.GetBeanTest">
        <lookup-method name="getBean" bean="teacher"></lookup-method>
    </bean>

    <bean id="teacher" class="com.alan.yx.springSource.chapter_3.lookup_method.Teacher"></bean>
</beans>
```

在这个配置文件中，我们看到了源码解析中提到的 lookup-method 子元素，这个配置完成的功能是动态地将 teacher 所代表的 bean 作为 getBean 的返回值，运行测试方法我们会看到控制台上的输出 :

	i am Teacher

当我们的业务变更或者在其他情况下， teacher 里面的业务逻辑已经不再符合我们的业务要求，需要进行替换怎么办呢?比如，这是我们需要增加新的逻辑类:

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="getBeanTest" class="com.alan.yx.springSource.chapter_3.lookup_method.GetBeanTest">
        <!-- 将来逻辑变更为 student-->
        <lookup-method name="getBean" bean="student"></lookup-method>
    </bean>

    <bean id="teacher" class="com.alan.yx.springSource.chapter_3.lookup_method.Teacher"></bean>

    <bean id="student" class="com.alan.yx.springSource.chapter_3.lookup_method.Student"></bean>
</beans>
```

#### 源码解析

```
BeanDefinitionParserDelegate:
public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++) {
			Node node = nl.item(i);
			// 仅当在 spring 默认 bean 的子元素下且为 <lookup method 有效
			if (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
				Element ele = (Element) node;
				// 获取要修饰的方法
				String methodName = ele.getAttribute(NAME_ATTRIBUTE);
				// 获取配置返回的bean
				String beanRef = ele.getAttribute(BEAN_ELEMENT);
				LookupOverride override = new LookupOverride(methodName, beanRef);
				override.setSource(extractSource(ele));
				overrides.addOverride(override);
			}
		}
	}
```

有没有觉得上面的代码很眼熟，似乎与 parseMetaElements 的代码大同小异，最大的区别就是在 if 判断中的节点名称在这里被修改为 `LOOKUP_METHOD_ELEMENT`。 还有一个区别，在数据存储上面通过使用 LookupOverride 类型的实体类来进行数据承载并记录在 AbstractBeanDefinition 中的 methodOverrides 属性中 。

#### 3.1.1.5 解析子元素 replaced-method

同样，在解析源码之前让我们先了解一下这个元素的用法。

方法替换:可以在运行时用新的方法替换现有的方法。 与之前的 look-up 不同的是，replaced-method 不但可以**动态地替换返回实体 bean**，而且还能**动态地更改原有方法的逻辑**。

#### 举个例子看下。




## 3.2 alias 标签的解析


## 3.3 import 标签的解析

## 3.4 嵌入式 beans 标签的解析