5 bean 的加载
====

经过前面的景点，我们已经参观了对 XML 配置文件的解析，接下来的景点将更加“绚丽”，也将面临更大的挑战。没错！这就是对 bean 加载的探索。

#### 为什么说更加“绚丽”呢？

因为 bean 加载的功能实现远比 bean 解析要复杂的多。一如既往，我们还是以开篇示例为引导，对于 bean 的加载， spring 中的调用方式为:

	MyTestBean bean = (MyTestBean) bf.getBean("myTestBean");
	
#### 这句话实现了什么样的功能呢？背后暗藏什么玄机？

让我们先来体验一下 spring 中代码是如何实现的吧～

``` java
protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
							  @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
		// 提取对应的 beanName
		final String beanName = transformedBeanName(name);
		Object bean;

		/**
		 * 单例在 Spring 的同一个容器内只会被创建一次，后续再获取 bean，就直接从单例缓存中获取了 。
		 * 当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从 singletonFactories 中加载。
		 * 因为在创建单例 bean 的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，
		 * 在 Spring 中创建 bean 的原则是: 不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早曝光加入到缓存中，
		 * 一旦下一个 bean 创建时候需要依赖上一个 bean 则直 接使用 ObjectFactory
		 */
		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null && args == null) {
			if (logger.isTraceEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
							"' that is not fully initialized yet - a consequence of a circular reference");
				} else {
					logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
				}
			}
			// 返回对应的实例，有时候存在诸如 BeanFactory 的情况并不是直接返回实例本身而是返回指定方法返回的实例
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		} else {
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			/**
			 * 只有在单例情况下才会尝试解决循环依赖，如果存在 A 中有 B 的属性， B 中有 A 的属性，
			 * 那么当依赖注入的时候，就会产生当 A 还未创建完的时候因为对于 B 的创建再次返回创建 A, 造成循环依赖，
			 * 也就是情况: isPrototypeCurrentlyInCreation(beanName) 判断为 true
			 */
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// Check if bean definition exists in this factory.
			// 如果 beanDefinitionMap 中也就是在所有已经加载的类中不包括 beanName, 则尝试从 parentBeanFactory 中检测
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
				// Not found -> check parent.
				String nameToLookup = originalBeanName(name);
				// 递归到 BeanFactory 中寻找
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				} else if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				} else if (requiredType != null) {
					// No args -> delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				} else {
					return (T) parentBeanFactory.getBean(nameToLookup);
				}
			}

			// 如果不是仅仅做类型检查，则是创建 bean,这里要进行记录
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				// 从 XML 配置文件中读取到的 bean信息是存储在 GernericBeanDefinition 中的 ，
				// 但是所有的 bean 后续处理都是针对于 RootBeanDefinition 的 ，所以这里需要进行一个转换，
				// 转换的同时如果父类 bean不为空的话，则会一并合并父类的属性。
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				// 如果存在依赖，需要递归实例化依赖的 bean
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
						}
						registerDependentBean(dep, beanName);
						try {
							getBean(dep);
						} catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
						}
					}
				}

				// 实例化依赖的 bean 后便可以实例化 mbd 本身了
				// singleton 模式的创建
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -> {
						try {
							return createBean(beanName, mbd, args);
						} catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				} else if (mbd.isPrototype()) {
					// It's a prototype -> create a new instance.
					// prototype 模式的创建
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					} finally {
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				} else {
					// 指定的 scope 上实例化 bean
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
					}
					try {
						Object scopedInstance = scope.get(beanName, () -> {
							beforePrototypeCreation(beanName);
							try {
								return createBean(beanName, mbd, args);
							} finally {
								afterPrototypeCreation(beanName);
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					} catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								"Scope '" + scopeName + "' is not active for the current thread; consider " +
										"defining a scoped proxy for this bean if you intend to refer to it from a singleton",
								ex);
					}
				}
			} catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}

		// 检查需要的类型是否符号 bean 的实际类型
		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null && !requiredType.isInstance(bean)) {
			try {
				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
				if (convertedBean == null) {
					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
				}
				return convertedBean;
			} catch (TypeMismatchException ex) {
				if (logger.isTraceEnabled()) {
					logger.trace("Failed to convert bean '" + name + "' to required type '" +
							ClassUtils.getQualifiedName(requiredType) + "'", ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;
	}
```

单看代码就能感受到 bean 的加载经历了一个相当复杂的过程，因为中间需要考虑很多的内容。不过现在不懂也没关系，参考上面的注释，还是可以粗略了解 bean 是怎么加载的。我们大致介绍一下基本的步骤，让你的心里有个“总览”，具体细节我们后面一一道来。

### 1. 转换对应 beanName

> 我猜你可能会疑惑转换对应 beanName 是什么意思。你可能会问传入的参数 name 不就是 beanName 吗?

其实不是，这里传入的参数可能是`别名`，也可能是 `FactoryBean`，所以需要进行一系列的解析，这些解析内容包括:

- 去除 FactoryBean 的修饰符，也就是如果 `name="&aa"`， 那么会首先去除 & 而使 `name ="aa”`。 

- 取指定 alias 所表示的最终 beanName

	> 例如别名 A 指向名称为 B 的 bean 则返回 B; 若别名 A 指向别名 B，另1]名 B 又指向名称为 C 的 bean 则返回 C。

### 2. 尝试从缓存中加载单例

单例在 Spring 的同一个容器内只会被创建一次，后续再获取 bean，就直接从单例缓存中获取了。 

> 实际上如果没有显示指定，spring 创建的 bean 的就是单例，因为很多的场景单例足够满足需要，这样可以节省开销(创建和存储)。

当然啦，这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从 singletonFactories 中加载。

因为在创建单例 bean 的时候会存在**`依赖注入`**的情况，而在创建依赖的时候为了避免循环依赖，在 Spring 中创建 bean 的原则是不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早曝光加入到缓存中, 一旦下一个 bean创建时候需要依赖上一个 bean则直 接使用 ObectFactory。

> 这个地方是解决循环依赖的重要解决方式，其实是利用了 3 级缓存: 
> 
> ```
> 
>  具体可见 DefaultSingletonBeanRegistry
>  /**
> 	 * Cache of singleton objects: bean name to bean instance.
> 	 * 缓存单例对象:(一级缓存)完成初始化的单例对象的cache
> 	 */
> 	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
> 
> 	/**
> 	 * Cache of singleton factories: bean name to ObjectFactory.
> 	 * 缓存单例工厂:(三级缓存) 进入实例化阶段的单例对象工厂的cache
> 	 */
> 	private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
> 
> 	/**
> 	 * Cache of early singleton objects: bean name to bean instance.
> 	 * 缓存单例对象：(二级缓存)完成实例化但是尚未初始化的，提前曝光的单例对象的Cache
> 	 */
> 	private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
> > ```

### 3. bean 的实例化

如果从缓存中得到了 bean 的原始状态，则需要对 bean 进行实例化。

这里有必要强调一下：缓存中记录的只是最原始的 bean 状态，井不一定是我们最终想要的 bean。 

> 举个例子，假如我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们 真正需 要的是工厂 bean 中定义的 factory-method  方法中返回的 bean，而 getObjectForBeanlnstance 就是完成这个工作的，我们会在后面详细讲解 。

### 4. 原型模式的依赖检查

只有在**单例情况**下才会尝试解决循环依赖。如果存在 A 中有 B 的属性， B 中有 A 的属性，那么当依赖注入的时候，就会产生当 A 还未创建完的时候因为对于 B 的创建再次返回创建 A, 造成循环依赖，也就是情况: `isPrototypeCurrentlyInCreation(beanName) `判断 true。

### 5. 检测 parentBeanFactory

#### 从代码上看，如果缓存没有数据的话直接转到父类工厂上去加载了，这是为什么呢? 

很容易忽略的一个很重要的判断条件是: `parentBeanFactory != null && !containsBeanDefinition(beanName)` , `parentBeanFactory != null`。 

- parentBeanFactory 如果为空，则其他一切都是浮云，这个就不用多说了，毕竟都没有父类工厂
- 但是 `!containsBeanDefinition(beanName)` 就比较重要了，它是在检测如果当前 加载的 XML 配置文件中不包含 beanName 所对应的配置（也就是所有已经加载的类中不包括 beanName），就只能到 parentBeanFactory 去尝试加载一下了，然后再去递归的调用 getBean 方法。

### 6. 将存储 XML 配置文件的 GernericBeanDefinition 转换为 RootBeanDefinition

因为从 XML 配置文件中读取到的 bean信息是存储在 G巳rnericBeanDefinition 中的 ，但是所 有的 bean 后续处理都是针对于 RootBeanDefinition 的 ，所以这里需要进行一个转换，转换的同时如果父类 bean不为空的话，则会一并合并父类的属性。

> @yx 你想啊，子类继承了父类，最终我们加载的 bean 肯定是需要把继承的属性一并加载过来的，不然这个继承就没啥意义了。

### 7. 寻找依赖

 bean 的初始化过程中很可能会用到某些属性，而某些属性很可能是动态配置的，并且可能配置成依赖于其他的 bean，那这个时候就有必要先加载依赖的 bean。
 
所以，在 Spring 的加载顺序中，在初始化某一个 bean 的时候首先会初始化这个 bean 所对应的依赖。

> @yx 就好像 A 类依赖于 B 类，那么 A 要想完成的使用它的方法属性，就必须把它的依赖准备好。
> 
> 这就好像你要过江，你依赖于一艘船，那么在过江之前就要先把船建好。

### 8. 针对不同的 scope 进行 bean 的创建

我们都知道，在 Spring 中存在着不同的 scope，默认的是 singleton，但是还有些其他的配置诸如 prototype、request、session 之类的。

在这个步骤中，Spring 会根据不同的配置进行不同的初始化策略 。

### 9. 类型转换

其实程序到这里返回 bean 后已经基本结束了。

一般来说，对该方法的调用参数 requiredType 是为空的，但是可能会存在这样的情况，返回的 bean 其实是个 String，但是 requiredType 却传入是 Integer 类型，那么这时候本步骤就会起作用了，它的功能是将返回的 bean 转换为 requiredType 所指定的类型。 

> 当然， String 转换为 Integer 是最简单的一种转换，在 Spring 中提供了各种各样的转换器，你也可以自己扩展转换器来满足你的需求。

终于，经过上面的步骤后 bean 的加载就结束了，这个时候就可以返回我们所需要的 bean 啦！

### bean 加载示意图

图 5-1 直观地反映了整个过程。其中最重要的就是步骤 8，针对不同的 scope 进行 bean 的创建，你会在这里看到各种常用的 Spring特性的实现。

<div align="center"> <img src="pics/5-1.png" width="500" style="zoom:140%"/> </div><br>

<div align="center"> <img src="pics/5-2.png" width="500" style="zoom:140%"/> </div><br>

在细化分析各个步骤提供的功能前，我们有必要先了解一下 FactoryBean 的用法。

> 这个概念很多搞不清 FactoryBean 和 BeanFactory 的区别和关系。事实上，他俩只是名字像而已，其实没啥“大关系”。

## 5.1 FactoryBean 的使用

#### 为什么要设计 FactoryBean？
一般情况下， Spring 通过反射机制利用 bean 的 class 属性指定实现类来实例化 bean 。 

在一些情况下，实例化 bean 过程比较复杂，如果按照传统的方式，则需要在 `<bean>` 中提供大量的配置信息，配置方式的灵前性是受限 的，这时采用编码的方式可能会得到一个简单的方案。 

Spring 为此提供了一个 `org.Springframework.bean.factory.FactoryBean` 的工厂类接口，**用户可以通过实现该接口定制实例化 bean 的逻辑。**

> @yx 简单来说，就是你想定制 bean 实例化的逻辑，那就实现 FactoryBean 接口吧！

#### FactoryBean 的基本信息

FactoryBean 接口对于 Spring 框架来说占有重要的地位，Spring 自身就提供了 70 多个 FactoryBean 的实现。它们隐藏了实例化一些复杂 bean 的细节，给上层应用带来了便利。从 Spring 3.0 开始，FactoryBean开始支持泛型，即接口声明改为 FactoryBean<T>的形式: 

```
package org.springframework.beans.factory;
public interface FactoryBean<T> {
	T getObject () throws Exception ; 
	Class<?> c;etObjectType(); 
	boolean isSingleton();
}
```

在该接口中还定义了以下 3 个方法:

* T getObject():  返回由 FactoryBean 创建的 bean 实例，如果 isSingleton()返回 true，则该实例会放到 Spring 容器中单实例缓存池中。

* boolean isSingleton(): 返回由 FactoryBean 创建的 bean 实例的作用域是 singleton 还是 prototype 。

* Class<T> getObjectType(): 返回 FactoryBean 创建的 bean 类型 。

当配置文件中<bean>的 class 属性配置的实现类是 FactoryBean 时，通过 getBean() 方法返回的可不是 FactoryBean 本身，而是 `FactoryBean#getObject()` 方法所返回的对象，相当于 `FactoryBean#getObject() `代理了 getBean()方法。

#### 看个例子

这样说有点抽象，我们来看个例子吧！例如:如果使用传统方式配置下面 Car 的 `<bean>` 时，Car 的每个属性分别对应一个` <property>`元素标签。 

``` java
public class Car {
	private int maxSpeed;
	private String brand;
	private double price 
	// get/set 方法
}
```

如果用 FactoryBean 的方式实现就会灵活一些，下例通过逗号分割符的方式一次性地为 Car 的所有属性指定配置值:

```
<bean id="car" class="com.alan.yx.springSource.chapter_5.factory_bean.CarFactoryBean"
          carInfo="跑车,400,200000000"></bean>
```

当调用 getBean(”car”) 时， Spring 通过**反射机制**发现 CarFactoryBean 实现了 FactoryBean 的接口，这时 Spring容器就调用接口方法 CarFactoryBean#getObject() 方法返回。 如果希望获取 CarFactoryBean 的实例，则需要在使用 getBean(beanName) 方法时在 beanName 前显示的加上 ”&”前缀，例如 getBean(”&car”)。

> @yx 还记得前面说的转换对应 beanName吗？这里的 factoryBean 正是其中转换的一种，现在看到用法就知道为什么源码中要加个 “&” 了。

